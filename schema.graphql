"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean = true

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type AccountInfoResult {
  rc_current: Int
  rc_max: Int
}

type AccountNonceResult {
  nonce: Int
}

type AnchorProducer {
  nextSlot(account: String): JSON
}

type Auth {
  value: String!
}

interface BalanceAccessCondition {
  type: BalanceAccessConditionType
  value: String
}

enum BalanceAccessConditionType {
  HASH
  TIME
  WITHDRAW
}

interface BalanceController {
  authority: String
  conditions: [BalanceAccessCondition]
  type: BalanceControllerType
}

enum BalanceControllerType {
  CONTRACT
  DID
  HIVE
}

type BalanceRecord {
  account: String
  block_height: Uint64!
  hbd: Int64!
  hbd_avg: Int64!
  hbd_claim: Uint64!
  hbd_modify: Uint64!
  hbd_savings: Int64!
  hive: Int64!
  hive_consensus: Int64!
}

interface BlockRef {
  block_ref: String
  included_block: Int
}

type Contract {
  code: String
  creation_ts: String
  id: String
}

type ContractDiff {
  diff: JSON
  previousContractStateId: String!
}

type ContractOutput {
  anchored_block: String
  anchored_height: Int
  anchored_id: String
  anchored_index: Int
  contract_id: String
  gas: Gas
  id: String!
  inputs: [String!]!
  results: [JSON]!
  side_effects: JSON
  state_merkle: String
}

type ContractState {
  id: String
  state(key: String): JSON
  stateKeys(key: String): JSON
  stateQuery(key: String, query: JSON): JSON
  state_merkle: String
}

interface DepositDrain {
  amount: Float
  deposit_id: String
  owner: String
  token: String
}

type ElectionMember {
  account: String!
  key: String!
}

type ElectionResult {
  block_height: Uint64!
  data: String!
  epoch: Uint64!
  members: [ElectionMember!]!
  net_id: String!
  proposer: String!
  protocol_version: Uint64!
  total_weight: Uint64!
  tx_id: String!
  type: String!
  weights: [Uint64!]!
}

input FindContractOutputFilter {
  byContract: String
  byInput: String
  byOutput: String
  limit: Int
}

type FindContractOutputResult {
  outputs: [ContractOutput]
}

type FindContractResult {
  status: String
}

input FindTransactionFilter {
  byAccount: String
  byAction: String
  byContract: String
  byId: String
  byOpCategory: String
  byStatus: String
  limit: Int
}

type FindTransactionResult {
  txs: [Transaction]
}

type Gas {
  IO: Int
}

type Headers {
  nonce: Int
}

scalar Int64

scalar JSON

type JsonPatchOp {
  op: String
  path: String
  value: JSON
}

type LedgerOp {
  amount: Int!
  block_height: Int!
  from: String
  id: String!
  idx: Float!
  memo: String
  owner: String!
  status: String!
  t: String!
  tk: String!
}

type LedgerResults {
  txs: [LedgerOp!]
}

input LedgerTxFilter {
  byToFrom: String
  byTxId: String
  limit: Int
  offset: Int
}

type LocalNodeInfo {
  did: String
  peer_id: String
}

type Mutation {
  incrementNumber: TestResult
}

type PostingJsonKeys {
  ct: String
  key: String
  t: String
}

type Query {
  activeWitnessNodes: JSON
  anchorProducer: AnchorProducer
  contractState(id: String): ContractState
  contractStateDiff(id: String): ContractDiff
  findContract(id: String): FindContractResult
  findContractOutput(decodedFilter: JSON, filterOptions: FindContractOutputFilter): FindContractOutputResult
  findLedgerTXs(filterOptions: LedgerTxFilter): LedgerResults
  findTransaction(decodedFilter: JSON, filterOptions: FindTransactionFilter): FindTransactionResult
  getAccountBalance(account: String!, height: Uint64): BalanceRecord
  getAccountNonce(keyGroup: [String]!): AccountNonceResult
  getCurrentNumber: TestResult
  getDagByCID(cidString: String!): JSON!
  getElection(epoch: Uint64!): ElectionResult
  localNodeInfo: LocalNodeInfo
  mockGenerateElection: JSON
  nextWitnessSlot(self: Boolean): JSON
  submitTransactionV1(sig: String!, tx: String!): TransactionSubmitResult
  witnessActiveScore(height: Int): JSON
  witnessNodes(height: Uint64!): [Witness!]!
  witnessSchedule(height: Uint64!): [WitnessSlot!]!
  witnessStake(account: String!): Uint64!
}

type TestResult {
  currentNumber: Int
}

type Transaction {
  accessible: Boolean
  anchored_block: String
  anchored_height: Int
  anchored_id: String
  anchored_index: Int
  anchored_op_index: Int
  data: TransactionData
  first_seen: String
  headers: Headers
  id: String!
  local: Boolean
  output: TransactionOutput
  required_auths: [Auth!]
  sig_hash: String
  src: String
  status: String!
}

type TransactionData {
  action: String
  contract_id: String
  op: String!
  payload: JSON
}

type TransactionOutput {
  id: String
  index: Int
}

enum TransactionStatus {
  CONFIRMED
  FAILED
  INCLUDED
  PROCESSED
  UNCONFIRMED
}

type TransactionSubmitResult {
  id: String
}

enum TransactionType {
  CORE
  INPUT
  NULL
  OUTPUT
  VIRTUAL
}

scalar Uint64

type Witness {
  account: String
  did_keys: [PostingJsonKeys!]!
  enabled: Boolean
  gateway_key: String
  git_commit: String
  height: Uint64!
  net_id: String
  peer_id: String
  protocol_version: Uint64!
  ts: String
  tx_id: String
  version_id: String
}

type WitnessSlot {
  account: String
  bn: Uint64!
}
